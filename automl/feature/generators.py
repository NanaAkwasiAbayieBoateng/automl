"""Feature Generators"""

import logging
from functools import partial
import random
import numpy as np
from sklearn.preprocessing import PolynomialFeatures





class SklearnFeatureGenerator:
    def __init__(self, transformer_class, *args, **kwargs):
        """
        Wrapper for Scikit-Learn Transformers

        Parameters
        ----------
        kwargs:
            keyword arguments are passed to sklearn PolynomialFeatures
        """
        self._log = logging.getLogger(self.__class__.__name__)
        self._transformer = transformer_class(*args, **kwargs)

    def __call__(self, dataset, pipeline_context):
        """
        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            The data.

        pipeline_context: automl.pipeline.PipelineContext
            global context of a pipeline

        Returns
        -------
        X_new : numpy array of shape [n_samples, n_features_new]
            Transformed array.
        """

        dataset.data = self._transformer.fit_transform(dataset.data)
        return dataset


class FormulaFeatureGenerator:
    def __init__(self, func_list=['+', '-', '*', '/']):
        """
        Initialize Formula Feature Generator

        Paramets
        --------
        func_list : list of symbols of functions
            In current version func_list may contain only '+', '-', '*', '/'.

        Attributes
        ----------
        _func_map : dict of generating functions
            The function for generation new features

        used_func : set of of symbols of functions
        """
        self.used_func = set(func_list)
        self._func_map = {
            '+': self._sum,
            '-': self._substract,
            '/': self._divide,
            '*': self._multiply,
        }

    def _sum(self, X):
        """
        Add one new feature generated by sum of two random features

        Parametrs
        ---------
        X : np.ndarray, shape [n_samples, n_features]
            The data to transform, row by row.

        Returns
        -------
        XF : np.ndarray shape [n_samples, n_features+1]
            The matrix of features with one new feature
        """
        x, y = self._choose_two_features(X)
        return np.append(X, x + y, axis=1)

    def _substract(self, X):
        """
        Add one new feature generated by substraction of two random features

        Parametrs
        ---------
        X : np.ndarray, shape [n_samples, n_features]
            The data to transform, row by row.

        Returns
        -------
        XF : np.ndarray shape [n_samples, n_features+1]
            The matrix of features with one new feature
        """
        x, y = self._choose_two_features(X)
        return np.append(X, x - y, axis=1)

    def _divide(self, X):
        """
        Add one new feature generated by division of two random features

        Parametrs
        ---------
        X : np.ndarray, shape [n_samples, n_features]
            The data to transform, row by row.

        Returns
        -------
        XF : np.ndarray shape [n_samples, n_features+1]
            The matrix of features with one new feature
        """
        x, y = self._choose_two_features(X)
        return np.append(X, x / y, axis=1)

    def _multiply(self, X):
        """
        Add one new feature generated by multiplication of two random features

        Parametrs
        ---------
        X : np.ndarray, shape [n_samples, n_features]
            The data to transform, row by row.

        Returns
        -------
        XF : np.ndarray shape [n_samples, n_features+1]
            The matrix of features with one new feature
        """
        x, y = self._choose_two_features(X)
        return np.append(X, x * y, axis=1)

    def _choose_two_features(self, X):
        """
        Choose two features from input data

        Parametrs
        ---------
        X : np.ndarray, shape [n_samples, n_features]
            The data

        Returns
        -------
        x, y : Two vectors of selected features
        """
        return X[:, random.randint(0, X.shape[1]-1)].reshape(X.shape[0], 1), \
               X[:, random.randint(0, X.shape[1]-1)].reshape(X.shape[0], 1)

    def __call__(self, dataset, limit, pipeline_context):
        """
        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            The data.

        limit : int
            Amount of new features

        pipeline_context: automl.pipeline.PipelineContext
            global context of a pipeline

        Returns
        -------
        XF : numpy array of shape [n_samples, n_features+limit]
            Transformed array.
        """
        if not isinstance(dataset.data, np.ndarray):
            X = np.array(dataset.data)
        for _ in range(0, limit):
            X = self._func_map[random.sample(self.used_func, 1)[0]](X)

        dataset.data = X
        return dataset 


PolynomialGenerator = partial(SklearnFeatureGenerator, PolynomialFeatures)
